#!/usr/bin/perl

# awrrpt.pl - Parse the AWR report into xanadu 3 format.

# Global variables
$tname, @headings, @head_type, @h_values, $flag, $SQLflag, $LineCnt, $HeadLineCnt, @table_names;

# Function definitions.

# Function to trim leading and trailing spaces.
sub trim($)
{
	my $string = shift;
	$string =~ s/^\s+//;
	$string =~ s/\s+$//;
	return $string;
}

# Function to sanitize the Table Name, by replacing -, . and / with _.
sub sanitizeTname {
    my($fname) = @_;
    $fname =~ s/\./_/g;
    $fname =~ s/\-/_/g;
    $fname =~ s/^.*\//_/g;
    $fname =~ s/\(/_/g;
    $fname =~ s/\)/_/g;
    $fname =~ s/^_+//;
    $fname;
}

# Function to open the input file and the CREATE and VIEW files.
# The data files for each table will be opened during the data extraction process.
sub open_awr_file {
		
	mkdir($out_dir,0755) unless (-d $out_dir);
#        open (AWRDATA, "$data_file") or die "Can't open data file $data_file. $!\n";

	$data_file = sanitizeTname ($data_file);
	open (AWRTABLE, ">$out_dir/$data_file.create") or die "Can't create output file $out_dir\/$data_file.create. Check permissions. $!\n";
	open (AWRVIEW, ">$out_dir/$data_file.view") or die "Can't create output file $out_dir\/$data_file.view. Check permissions. $!\n";
}

# Function to close all the opened files.
sub close_awr_file {
	close (AWRDATA);
	close (AWRTABLE);
	close (AWRVIEW);
}

# Function to create the data file for a table, and load it with the data in Xanadu 3 format.
sub print_data {

	# The output file name for the table is generated by concatenating the sanitized datafile name with the table name.
	$awr_data_out=$out_dir."\/".$data_file."_".$tname.".data";
	open (AWRTABLEDATA, ">$awr_data_out") or die "Can't create output data file. Check permissions. $!\n";
	
	# If the table data contains a number of '#' instead of the actual value, it is substituted with null.
	# Similarly leading . (decimal point) is preceeded with a 0.
	while (@h_values) {
                $out = shift (@h_values);
		$out =~ s/^#+$//;
		$out =~ s/^\./0\./;
#		$out =~ s/^$/ /;
		print AWRTABLEDATA $out;
        }
	close (AWRTABLEDATA);
}

# Function to output the view to the VIEW file. (Just doing a Select * for now.)
# Need to update this to add custom views and for graphing.
sub print_view {
	print AWRVIEW "$data_file|", $tname, "|table|1|select * from ", $data_file, "_", $tname, "\n"; 
}

# Function responsible for the data generated for a table to be written to the files.
# For the Create Table, it reads the column names from @headings and the types from @head_type (Global Variables).
# After writing this to the CREATE file, it calls print_data() and print_view() functions to generate the DATA and VIEW files respectively. 
sub print_create {
	
# Check if the table name is already in existance.
	if (@table_names) {
		foreach $tablename (@table_names) {
			if ($tablename eq $tname) {
				if ($tablename =~ /.*[0-9]$/) {
					$lastdigit = chop ($tname)+1;
					$tname .= $lastdigit;
				} else {
					$tname .= "_1";
				}
				
			}	
		}
	}
	push @table_names, $tname;

        $create = "Create table ".$data_file."_".$tname." \(\"";
	$i=1;
	# This was added to remove duplicate column name occurances.
	# Derby does not like duplicate column names in the same table.
	foreach $temp_val (@headings) {
		for ($temp_cnt=$i++; $temp_cnt<=scalar(@headings); $temp_cnt++) {
			if ($temp_val eq $headings[$temp_cnt]) { 
				$headings[$temp_cnt] = $headings[$temp_cnt-1]."_".$headings[$temp_cnt]; 
			}
		}
	}
	
	if (@headings) {
                $create .= shift(@headings)."\" ".shift(@head_type);
                $col++;
        	while (@headings) {
	                $create .=  ", \"".shift(@headings)."\" ".shift(@head_type);
	                $col++;
	        }
		$create .= "\)\n";	
		print AWRTABLE $create;
		&print_data ();
		&print_view ();
	} else {
		print "No data in table awr_out_", $tname, "\n";
	}
}

# Function to process the heading columns of a section of the awr output.
# It gets the currently read line as an argument. This is used to generate the table name.
# It can process multiple header rows also. 
sub process_header {
	my ($head) = @_;
	$i = 0;
	$flag = 0;
	$heading[$i++] = $head;
	$_ = <AWRDATA>; $HeadLineCnt++;

	# Check to see if there is any data in the section.
	if (/^\s*No data exists.*/) { return; }

	# Read until ----. This is assumed as the separator between the header and the data for the table.
	until (/^-+/) {
		$heading[$i++] = $_;
		$_ = <AWRDATA>; $HeadLineCnt++;
	}
	$line = $_;
	print "Head Line Count is: ", $HeadLineCnt, "\nLine is: ", $_, ":", $flag, "\n";
	
	# This section is to read another row of column headers, if it exists.
	$pos = tell (AWRDATA);
	<AWRDATA>;

# Earlier I checked just for /^-+/, but this was causing problems with the Rule Set section in
# statspack. Now, for every extra row of header, the beginning field cannot be 1 char long.
	$_ = <AWRDATA>; if (/^--+/) { $flag = 1; }
	$_ = <AWRDATA>;	if (/^--+/) { $flag = 1; }
	$_ = <AWRDATA>; if (/^--+/) { $flag = 1; }
	seek (AWRDATA, $pos, 0);
	# End of section. Set flag to work.

#	print "FLAG: ", $flag, "\n";

	# The columns are split based on the gaps in the separator. Here it is assumed that there is only 1 space gap.
	# May need to modify this to accomodate multiple spaces also.
	foreach $colbound (split(/\s/, $line)) {
                $head_val = "";
		for ($cnt=0; $cnt<$i; $cnt++) {
			$val = substr ($heading[$cnt], 0, length ($colbound)+1);

# The following line has been added to filter out the <----> in Wiat Event Histogram for Statspack output.
			if ($heading[$cnt] =~ /^--+/) { $heading[$cnt] = ""; $val = ""; }	
			$heading[$cnt] =~ s/\Q$val\E//;
			$head_val .= " ".trim ($val);
		}
		if (trim ($head_val) eq "") {$head_val = "Stat";}
                push @headings, trim ($head_val);
        }
	
	# In case there are more rows to the header, flag would have been set to 1.
	# For multiple row header, it is assumed that there would be a separator line between the 2 rows.
	# For now, it is assumed that a max of 2 rows of header only occur.
	if ($flag == 1) {
		$i = 0;
		$_ = <AWRDATA>; $HeadLineCnt++;
		until (/^-+/) {
       		        $heading[$i++] = $_;
       		        $_ = <AWRDATA>; $HeadLineCnt++;
       		}
        	$line1 = $_;
	
		foreach $colbound (split(/\s/, $line1)) {
	                $head_val = "";
	                for ($cnt=0; $cnt<$i; $cnt++) {
	                        $val = substr ($heading[$cnt], 0, length ($colbound)+1);
	                        $heading[$cnt] =~ s/\Q$val\E//;
	                        $head_val .= " ".trim ($val);
	                }
	                if (trim ($head_val) eq "") {$head_val = "Stat";}
			push @headings, trim ($head_val);
			push @head_type, "integer";
	        }
		$line = trim ($line)." ".$line1;
	}
	if ($SQLflag == 1) { push @headings, "SQL Query"; } 
	print "\n--- Done Header Processing --- ", $HeadLineCnt, "\n";
}

# Function to process a section of the report.
# This first calls the process_header() function, to get the number of columns and their names.

sub process_statspack_section {
	my ($heading) = @_;
	$flag = 0;
	$SQLflag = 0;
	$LineCnt = 0;
	$HeadLineCnt = 0;
	
	unless ($heading) { $heading = $_; }
	while ($heading =~ /^\n$/) { $_ = $heading = <AWRDATA>; }

#--- Getting the SQL Memory Statistics.
#        $_ = $heading = <AWRDATA>;
        if (/^\s*(SQL Memory Statistics)/) { &process_awr_SQLMemStats ($heading); return; }

	$tname = trim ($heading);
	if ($tname =~ /for DB/) {
		$tname = substr ($tname, 0, index ($tname, "for DB"));
	}
	$tname = substr ($tname, 0, index ($tname, "  "));
	$tname =~ s/\s\-\s/ /g;  # This is to remove any " - " occurances, since '-' is not liked by Derby.
	$tname = sanitizeTname ($tname);
	if ($tname =~ /SQL/) { $SQLflag = 1; }
	$HeadLineCnt++;
	
	until ($heading =~ /^\n$/) { $_ = $heading = <AWRDATA>; $HeadLineCnt++;}
#	print "TNAME: ", $tname, "\n";

# This section has been added since there are two tables in the PGA Aggr Target Stats section.
# So, we omit the first one since it does not give much information. 
	if ( index ($tname, "Aggr Target Stats") > 0 ) { 
		$_ = $heading = <AWRDATA>; $HeadLineCnt++;
		until ($heading =~ /^\n$/) { $_ = $heading = <AWRDATA>; $HeadLineCnt++;}
	}
	&process_header ($heading);
#	print "\nOutside header, into section processing...\n";

	$LineCnt = $HeadLineCnt;
	$_ = $values = <AWRDATA>; $LineCnt++;
	unless (/^\s*-+$/) { if ($flag == 1) {
		$_ = <AWRDATA>; $LineCnt++;
		$values .= " ".$_;
	}}
#	print "\nValues: ", $values;

        if (/^\n$/) {
                $_ = $values = <AWRDATA>; $LineCnt++;
                if ($LineCnt > 60) {
                        for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
                        $_ = $values = <AWRDATA>; $LineCnt = $HeadLineCnt+1;
                }
        }

	until (/^\s\s\s\s\s\s\s\s\s\s-+$/) {
#	until (/^\s+-+$/) {
		$head_pos = 0;
	
		foreach $colbound (split(/\s/, $line)) {
			$value = substr ($values, 0, length($colbound)+1);
		        if ($value =~ /\n/) {
				@temp = split (/\n/, $value);
				$value = $temp[0]."\n";
			}
			$values =~ s/\Q$value\E//;
#			print "\n Val: ", $value;
                	$value = trim ($value);
                        push @h_values, $value;
			push @h_values, "|";
			
			if ($value =~ /^\d+$/) { if (($head_type[$head_pos] =~ /^varchar/) || ($head_type[$head_pos] =~ /^real/)) {}
				else { 
					if (length ($value) > 9) { $head_type[$head_pos] = "bigint"; }
					else { unless ($head_type[$head_pos] eq "bigint") { $head_type[$head_pos] = "integer"; }}
				}
			}
			elsif ($value =~ /^\d*\.\d+$/) { 
				if ($head_type[$head_pos] =~ /^varchar/) {} else {$head_type[$head_pos] = "real";} 
			}
			else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
			$head_pos++;
		}
		$_ = $values = <AWRDATA>; $LineCnt++;
		if ($LineCnt > 60) {
			for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
			$_ = $values = <AWRDATA>; $LineCnt = $HeadLineCnt+1;
		}	
		if ($SQLflag == 1) {
			$value = "";
			until (/^\n$/) {
#				print $LineCnt, ":";
				$value .= trim ($values);
				$_ = $values = <AWRDATA>; $LineCnt++;
				if ($LineCnt > 60) {
               			        for ($ctr = 0; $ctr<$HeadLineCnt; $ctr++ ) { $_ = $values = <AWRDATA>; }
					$LineCnt = $HeadLineCnt+1;
                		}

			}
			push @h_values, $value;
			push @h_values, "|";
			$head_type[$head_pos] = "varchar(1000)";
		}
		pop @h_values;	
		push @h_values, "\n";
	
		if (/^\n$/) {
                        $_ = $values = <AWRDATA>; $LineCnt++;
                        if ($LineCnt > 60) {
                                for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
                                $_ = $values = <AWRDATA>; $LineCnt = $HeadLineCnt+1;
                        }
                }
	
		unless (/^\s*-+$/) { if ($flag == 1) {
	                $_ = <AWRDATA>; $LineCnt++;
			if ($LineCnt > 60) {
                                for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
				$_ = <AWRDATA>; $LineCnt = $HeadLineCnt+1;
                        }
			$values .= " ".$_;
        	}}
#		print "\nDone till here : ", $SQLflag, " ", $LineCnt, "\n";

		if (/^\n$/) {
                        $_ = $values = <AWRDATA>; $LineCnt++;
                        if ($LineCnt > 60) {
                                for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
                                $_ = $values = <AWRDATA>; $LineCnt = $HeadLineCnt+1;
                        }
		}
        }
	$tname =~ s/\s/_/g;
#        print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
	&print_create ();

}

sub process_section {
	my ($heading) = @_;
	$flag = 0;
	$SQLflag = 0;
	$LineCnt = 0;
	$HeadLineCnt = 0;
	
	unless ($heading) { $heading = $_; }
	while ($heading =~ /^\n$/) { $_ = $heading = <AWRDATA>; }
	
	$tname = trim ($heading);
	$tname = substr ($tname, 0, index ($tname, "  "));
	$tname =~ s/\s\-\s/ /g;  # This is to remove any " - " occurances, since '-' is not liked by Derby.
	$tname = sanitizeTname ($tname);
	if ($tname =~ /SQL/) { $SQLflag = 1; }
	$HeadLineCnt++;
	
	until ($heading =~ /^\n$/) { $_ = $heading = <AWRDATA>; $HeadLineCnt++;}
	&process_header ($heading);
#	print "\nOutside header, into section processing...\n";

	$_ = $values = <AWRDATA>; $LineCnt++;
	unless (/^\s*-+$/) { if ($flag == 1) {
		$_ = <AWRDATA>; $LineCnt++;
		$values .= " ".$_;
	}}
#	print "\nValues: ", $values;

        if (/^\n$/) {
                $_ = $values = <AWRDATA>; $LineCnt++;
                if ($LineCnt > 60) {
                        for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
                        $_ = $values = <AWRDATA>; $LineCnt = 1;
                }
        }

	until (/^\s*-+$/) {
		$head_pos = 0;
		foreach $colbound (split(/\s/, $line)) {
			$value = substr ($values, 0, length($colbound)+1);
		        if ($value =~ /\n/) {
				@temp = split (/\n/, $value);
				$value = $temp[0]."\n";
			}
			$values =~ s/\Q$value\E//;
#			print "\n Val: ", $value;
                	$value = trim ($value);
                        push @h_values, $value;
			push @h_values, "|";
		
			if ($value =~ /^\d+$/) { if (($head_type[$head_pos] =~ /^varchar/) || ($head_type[$head_pos] =~ /^real/)) {}
                                else {
                                        if (length ($value) > 9) { $head_type[$head_pos] = "bigint"; }
                                        else { unless ($head_type[$head_pos] eq "bigint") { $head_type[$head_pos] = "integer"; }}
                                }
                        }
			elsif ($value =~ /^\d*\.\d+$/) { 
				if ($head_type[$head_pos] =~ /^varchar/) {} else {$head_type[$head_pos] = "real";} 
			}
			else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
			$head_pos++;
		}
		$_ = $values = <AWRDATA>; $LineCnt++;
		if ($LineCnt > 60) {
			for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
			$_ = $values = <AWRDATA>; $LineCnt = 1;
		}	
		if ($SQLflag == 1) {
			$value = "";
			until (/^\n$/) {
#				print $LineCnt, ":";
				$value .= trim ($values);
				$_ = $values = <AWRDATA>; $LineCnt++;
				if ($LineCnt > 60) {
               			        for ($ctr = 0; $ctr<$HeadLineCnt; $ctr++ ) { $_ = $values = <AWRDATA>; }
					$LineCnt = 1;
                		}

			}
			push @h_values, $value;
			push @h_values, "|";
			$head_type[$head_pos] = "varchar(1000)";
		}
		pop @h_values;	
		push @h_values, "\n";
		unless (/^\s*-+$/) { if ($flag == 1) {
	                $_ = <AWRDATA>; $LineCnt++;
			if ($LineCnt > 60) {
                                for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
				$_ = <AWRDATA>; $LineCnt = 1;
                        }
			$values .= " ".$_;
        	}}
#		print "\nDone till here : ", $SQLflag, " ", $LineCnt, "\n";

		if (/^\n$/ || /^\s{10}\s+-+$/) {
                        $_ = $values = <AWRDATA>; $LineCnt++;
                        if ($LineCnt > 60) {
                                for ($ctr = 1; $ctr<$HeadLineCnt; $ctr++ ) { <AWRDATA>; }
                                $_ = $values = <AWRDATA>; $LineCnt = 1;
                        }
		}
        }
	$tname =~ s/\s/_/g;
#        print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
	&print_create ();
}

sub process_awr_db {
	my ($heading) = @_;
	$tname = "Database";
 
	$line = <AWRDATA>;
        $values = <AWRDATA>;
	$row = 0;
	$head_pos = 0;
	
	$index = index ($line, "--");
	if ($index > 0) {
		$line = substr ($line, $index, length ($line)+1);
		$values = substr ($values, $index, length ($values)+1);
		$heading = substr ($heading, $index, length ($heading)+1);
#		print "Head: ", $heading, "\nValues: ", $values, "\n";
	}

        foreach $colbound (split(/\s/, $line)) {
                $heading_val = substr ($heading, 0, length($colbound)+1);
                $value = substr ($values, 0, length($colbound)+1);

                $heading =~ s/\Q$heading_val\E//;
                $values =~ s/\Q$value\E//;

                $heading_val = trim($heading_val);
                $value = trim ($value);

                push @headings, $heading_val;
                push @h_values, $value;
		push @h_values, "|";
		
		if ($value =~ /^\d*$/) {
			$head_type[$head_pos] = "integer"; }
                elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                        $head_type[$head_pos] = "real";
                }
                else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                $head_pos++;

        }
	pop @h_values;
	push @h_values, "\n";
	
	&print_create($row);
	return 1;
}

sub process_awr_snap {
	my ($heading) = @_;
	$tname = "Snapshot";
	$line = <AWRDATA>;
	$head_pos = 0;
	$index = index ($line, "--");

	$line = substr ($line, $index, length ($line)+1);
#	$line = trim ($line);
	$heading_val = substr ($heading, 0, $index);
	$heading =~ s/\Q$heading_val\E//;

	push @headings, "Stat";
	foreach $colbound (split (/\s/, $line)) {
		$heading_val = substr ($heading, 0, length($colbound)+1);
		$heading =~ s/\Q$heading_val\E//;
		$heading_val = trim ($heading_val);
		push @headings, $heading_val;
#		print "\nHead Val: ", $heading_val;
	}

	$row = 0;
	$_ = $values = <AWRDATA>;
	$head_type[$head_pos++] = "varchar(".($index+1).")";
	until (/^\n$/) {
		$col = 0;
		$value = substr ($values, 0, $index);
		$values =~ s/\Q$value\E//;
                $value = trim ($value);
		push @h_values, $value;
		push @h_values, "|";
		foreach $colbound (split (/\s/, $line)) {
			$value = substr ($values, 0, length ($colbound)+1);
			$values =~ s/\Q$value\E//;
			$value = trim ($value);
			push @h_values, $value;
			push @h_values, "|";	
			if ($value =~ /^\d+$/) { if (($head_type[$head_pos] =~ /^varchar/) || ($head_type[$head_pos] =~ /^real/)) {}
                                else {
                                        if (length ($value) > 9) { $head_type[$head_pos] = "bigint"; }
                                        else { unless ($head_type[$head_pos] eq "bigint") { $head_type[$head_pos] = "integer"; }}
                                }
                        }
                        elsif ($value =~ /^\d*\.\d+$/) {
                                if ($head_type[$head_pos] =~ /^varchar/) {} else {$head_type[$head_pos] = "real";}
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }

#			if ($value =~ /^\d+$/) {
#	                        $head_type[$head_pos] = "integer";
#			}
#	                elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
#	                        $head_type[$head_pos] = "real";
#	                }
#	                else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }

	                $head_pos++;
		}
		pop @h_values;
		push @h_values, "\n";
		$row++;
		$_ = $values = <AWRDATA>;
	}
#	print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
	&print_create();
}

sub process_awr_cache {
	my ($heading) = @_;
#	print "Cache Head: ", $heading;
	$tname = "Cache";
	$line = <AWRDATA>;
	$head_pos = 0;
	$index = index ($line, "--");
	if ($index == -1) { 
		print "index=0\n"; 
		until (/^\n$/) {
			$_ = <AWRDATA>;
		}
		return; 
	}
	my ($extra);

	$line = substr ($line, $index, length ($line)+1);
        $heading = trim (substr ($heading, $index, length($heading)));

        push @headings, "Stat";
        foreach $colbound (split (/\s/, $line)) {
                $heading_val = substr ($heading, 0, length($colbound)+1);
                $heading =~ s/\Q$heading_val\E//;
                $heading_val = trim ($heading_val);
                push @headings, $heading_val;
        }

        $_ = $values = <AWRDATA>;
	$head_type[$head_pos++] = "varchar(".($index+1).")";
        until (/^\n$/) {
                $col = 1;
                $value = substr ($values, 0, $index);
                $values =~ s/\Q$value\E//;
                $value = trim ($value);
                push @h_values, $value;
		push @h_values, "|";
		
                foreach $colbound (split (/\s/, $line)) {
                        $value = substr ($values, 0, length ($colbound)+1);
                        $values =~ s/\Q$value\E//;
                        $value = trim ($value);
#			unless ($head_type[$head_pos] eq "integer") { if ($value eq null) {$value = " "; }}
               		push @h_values, $value;
	                push @h_values, "|";
			if ($value =~ /^\d*$/) {
                                $head_type[$head_pos] = "integer"; }
                        elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                                $head_type[$head_pos] = "real";
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                        $head_pos++;
			$col++;
		}
		pop @h_values;
		push @h_values, "\n";	
		$extra .= $values .= "\t";
                $_ = $values = <AWRDATA>;
        }
	$extra = trim ($extra);
	foreach $other (split (/\t/, $extra)) {
		trim ($other);
#		@other_val = split (/:/, $other);
		foreach $i (split (/:/, $other)) {
			push @h_values, trim($i);
			push @h_values, "|";
		}
		for ($j=0; $j<$col-2; $j++) { push @h_values, "|"; }
		pop @h_values;
		push @h_values, "\n";
	}
	&print_create ();	
}

sub process_awr_profile {
	my ($heading) = @_;
	$tname = "Profile";
        $line = <AWRDATA>;
	$head_pos = 0;
        $index = index ($line, "--");
        my ($extra);

#        $line = trim ($line);
	$line = substr ($line, $index, length ($line)+1);
        $heading = substr ($heading, $index, length($heading));
        push @headings, "Stat";

        foreach $colbound (split (/\s+/, $line)) {
                $heading_val = substr ($heading, 0, length($colbound));
                $heading =~ s/\Q$heading_val\E//;
		$heading = trim ($heading);
                $heading_val = trim ($heading_val);
                push @headings, $heading_val;
        }
	
        $_ = $values = <AWRDATA>;
	$head_type[$head_pos++] = "varchar(".($index+1).")";

        until (/^\n$/) {
                $col = 1;
                $value = substr ($values, 0, $index+1);
                $values =~ s/\Q$value\E//;
                $value = trim ($value);
                push @h_values, $value;
		push @h_values, "|";

                foreach $colbound (split (/\s+/, $line)) {
                        $value = substr ($values, 0, length ($colbound)+1);
			$values =~ s/\Q$value\E//;
			$values = trim ($values);
                        $value = trim ($value);
                        push @h_values, $value;
			push @h_values, "|";
			if ($value =~ /^\d*$/) {
                                $head_type[$head_pos] = "integer"; }
                        elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                                $head_type[$head_pos] = "real";
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                        $head_pos++;
			$col++;
                }
		pop @h_values;
                push @h_values, "\n";
		$_ = $values = <AWRDATA>;
        }
	$_ = $values = <AWRDATA>;
        until (/^\n$/) {
		foreach $awrline (split (/\n/, $_)) {
			trim ($awrline);
			foreach $other (split (/\d\s+/, $awrline)) {
		                trim ($other);
#				@other_val = split (/:/, $other);
		                foreach $i (split (/:/, $other)) {
               		        	push @h_values, trim($i);
                        		push @h_values, "|";
                		}
				for ($j=0; $j<$col-2; $j++) { push @h_values, "|"; }
				pop @h_values;
                		push @h_values, "\n";
       		 	}
			$_ = $values = <AWRDATA>;
		}
	}
	&print_create();
}

sub process_awr_eff {
	$tname = "Efficiency";	
	push @headings, "Instance Detail", "Percentage(%)";
	$head_type[0] = "varchar(40)";
	$head_type[1] = "real";
	<AWRDATA>;
	$_ = <AWRDATA>;
	until (/^\n$/) {
		$field1 = substr($_, 0, 40);
		$field2 = substr($_, 40);
		
		trim ($field1);
		trim ($field2);
		@fields = split (':', $field1);
		push @h_values, trim ($fields[0]);
		push @h_values, "|";
		push @h_values, trim ($fields[1]);
		push @h_values, "\n";
	
		
		@fields = split (':', $field2);
                push @h_values, trim ($fields[0]);
                push @h_values, "|";
                push @h_values, trim ($fields[1]);
		push @h_values, "\n";
		$_ = <AWRDATA>;
	}
	&print_create ();
}

sub process_awr_sharedpool {
        my ($heading) = @_;
	$tname = "Sharedpool";
	$line = <AWRDATA>;
	$head_pos = 0;
        $index = index ($line, "--");

        $line = trim ($line);
        $heading_val = substr ($heading, 0, $index);
        $heading =~ s/\Q$heading_val\E//;
	push @headings, "Stat";
	
	foreach $colbound (split (/\s\s/, $line)) {
                $heading_val = substr ($heading, 0, length($colbound)+1);
                $heading =~ s/\Q$heading_val\E//;
                $heading_val = trim ($heading_val);
                push @headings, $heading_val;
        }

        $row = 0;
        $_ = $values = <AWRDATA>;
	$head_type[$head_pos++] = "varchar(".($index+1).")";
        until (/^\n$/) {
                $col = 0;
                $value = substr ($values, 0, $index);
                $values =~ s/\Q$value\E//;
                $value = trim ($value);
                push @h_values, $value;
		push @h_values, "|";

                foreach $colbound (split (/\s\s/, $line)) {
                        $value = substr ($values, 0, length ($colbound)+1);
                        $values =~ s/\Q$value\E//;
                        $value = trim ($value);
                        push @h_values, $value;
			push @h_values, "|";
			if ($value =~ /^\d+$/) {
                                $head_type[$head_pos] = "integer"; }
                        elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                                $head_type[$head_pos] = "real";
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                        $head_pos++;

                }
		pop @h_values;
                push @h_values, "\n";
		$_ = $values = <AWRDATA>;
        }
#        print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
	&print_create ();
}

sub process_awr_top {
        my ($head) = @_;
        $tname = "Top5Events";
        $head_pos = 0;

        $i = 0;
        $heading[$i++] = $head;
        $_ = <AWRDATA>;

        # Check to see if there is any data in the section.
        if (/^\s*No data exists.*/) { return; }

        # Read until ----. This is assumed as the separator between the header and the data for the table.
        until (/^-+/) {
		if (/^~+/) {
			$spaces = index ($_, "~ ")+1;
			$substring = substr ($heading[$i-1], 0, index ($_, "~ ")+1);
			$heading[$i-1] =~ s/\Q$substring\E/" " x $spaces/e;
			$_ =~ s/~/ /g;
#			print $heading[$i-1], " : ", $_, "END\n";
		}
                $heading[$i++] = $_;
		$_ = <AWRDATA>;
        }
        $line = $_;

        # The columns are split based on the gaps in the separator. Here it is assumed that there is only 1 space gap.
        # May need to modify this to accomodate multiple spaces also.
        foreach $colbound (split(/\s/, $line)) {
                $head_val = "";
                for ($cnt=0; $cnt<$i; $cnt++) {
                        $val = substr ($heading[$cnt], 0, length ($colbound)+1);
                        $heading[$cnt] =~ s/\Q$val\E//;
                        $head_val .= " ".trim ($val);
                }
                if (trim ($head_val) eq "") {$head_val = "Stat";}
                push @headings, trim ($head_val);
        }

        $row = 0;
        $_ = $values = <AWRDATA>;
#        $head_type[$head_pos++] = "varchar(".($index+1).")";
        until (/^\s+-+$/) {
                $col = 0;
                foreach $colbound (split (/\s/, $line)) {
                        $value = substr ($values, 0, length ($colbound)+1);
                        $values =~ s/\Q$value\E//;
                        $value = trim ($value);
                        push @h_values, $value;
                        push @h_values, "|";
                        if ($value =~ /^\d+$/) {
                                $head_type[$head_pos] = "integer"; }
                        elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                                $head_type[$head_pos] = "real";
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                        $head_pos++;
                }
                pop @h_values;
                push @h_values, "\n";
                $_ = $values = <AWRDATA>;
        }
#        print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
        &print_create ();
}

sub process_awr_SQLMemStats {
        $tname = "SQL_Memory_Statistics";
        until (/^\n$/) { $_ = $heading = <AWRDATA>; }
	$_ = $heading = <AWRDATA>;
	$line = <AWRDATA>;
#	print $line, "--\n";
        $head_pos = 0;
        $index = index ($line, "--");

        $line = trim ($line);
        $heading_val = substr ($heading, 0, $index);
        $heading =~ s/\Q$heading_val\E//;
        push @headings, "Stat";

        foreach $colbound (split (/\s/, $line)) {
                $heading_val = substr ($heading, 0, length($colbound)+1);
                $heading =~ s/\Q$heading_val\E//;
                $heading_val = trim ($heading_val);
                push @headings, $heading_val;
        }

        $row = 0;
        $_ = $values = <AWRDATA>;
        $head_type[$head_pos++] = "varchar(".($index+1).")";
        until (/^\s+-+$/) {
                $col = 0;
                $value = substr ($values, 0, $index);
                $values =~ s/\Q$value\E//;
                $value = trim ($value);
                push @h_values, $value;
                push @h_values, "|";

                foreach $colbound (split (/\s/, $line)) {
                        $value = substr ($values, 0, length ($colbound)+1);
                        $values =~ s/\Q$value\E//;
                        $value = trim ($value);
                        push @h_values, $value;
                        push @h_values, "|";
                        if ($value =~ /^\d+$/) {
                                $head_type[$head_pos] = "integer"; }
                        elsif ($value =~ /^\d*.\d*$/ && $head_type[$head_pos] eq "integer") {
                                $head_type[$head_pos] = "real";
                        }
                        else { $head_type[$head_pos] = "varchar(".(length($colbound)+1).")"; }
                        $head_pos++;

                }
                pop @h_values;
                push @h_values, "\n";
                $_ = $values = <AWRDATA>;
        }
#        print "Heading : ", @headings, "\nValues : ", @h_values, "\n";
        &print_create ();
}

sub process_report {

#--- Determine if the report is Awr or Statspack
	open (AWRDATA, "$data_file") or die "Can't open data file $data_file. $!\n";

	$_ = <AWRDATA>;
	while (/^\n$/) { $_ = <AWRDATA>; }
#	print "Something here:",$_;
	if (/^STATSPACK/) { 
		&process_statspack;
#		print "Statspack\n";
	}
	elsif (/^WORKLOAD REPOSITORY/) { 
		&process_awr;
#		print "Awr Report\n";
	}
}

sub process_statspack {

	&open_awr_file;
#---  Getting the DBBench Header.
        $_ = $heading = <AWRDATA>;
		print $_;
        until ($heading =~ /^Database/ || /^\s*(DB)\s*/ ) { $_ = $heading = <AWRDATA>; print $_; }
		print "Processing Database... \n";
        &process_awr_db ($heading);
#--- Getting the Snapshot details.
        $_ = $heading = <AWRDATA>;
        until (/^Snapshot/ || /^\s*(Snap Id)\s*/ ) {$_ = $heading = <AWRDATA>; }
		print "Processing snapshot... \n";
        &process_awr_snap ($heading);
#--- Getting the Cache details.
        $_ = $heading = <AWRDATA>;
        until (/^Cache/) {$_ = $heading = <AWRDATA>; }
        &process_awr_cache ($heading);
#--- Getting the Profle details.
        $_ = $heading = <AWRDATA>;
        until (/^Load Profile/) {$_ = $heading = <AWRDATA>; }
        if (/^Load Profile\s*$/) {$_ = $heading = <AWRDATA>; }
		&process_awr_profile ($heading);
#--- Getting the Instance Effeciency details.
        $_ = $heading = <AWRDATA>;
        until (/^Instance Efficiency/) {$_ = $heading = <AWRDATA>; }
        &process_awr_eff;
#--- Getting the Shared Pool Statistics.
        $_ = $heading = <AWRDATA>;
        until (/^\s*(Shared Pool Statistics)/) {$_ = $heading = <AWRDATA>; }
        &process_awr_sharedpool ($heading);
#--- Getting the Top 5 Timed Events.
	$_ = $heading = <AWRDATA>;
	until (/^Top 5 Timed/) {$_ = $heading = <AWRDATA>; }
	&process_awr_top ($heading);

#--- Getting the rest of the data.
        $_ = $heading = <AWRDATA>;
        until (/^\s*-+$/) {$_ = $heading = <AWRDATA>; }
        $_ = $heading = <AWRDATA>;
        &process_statspack_section ();

#--- Getting the rest of the data.
        until (/^End of Report/) {
                $_ = $heading = <AWRDATA>;
                while (/^\n$/) {$_ = $heading = <AWRDATA>; }
#		print "Next -> ", $_, "\n";
                unless (/^End of Report/) { &process_statspack_section ($heading); }
        }

        &close_awr_file;

}

sub process_awr {

	&open_awr_file;
	
#---  Getting the DBBench Header.
	$_ = $heading = <AWRDATA>;
	until (/^\s*(DB)\s*/) { $_ = $heading = <AWRDATA>; }
	&process_awr_db ($heading);
#--- Getting the Snapshot details.
	$_ = $heading = <AWRDATA>;
        until (/^\s*(Snap Id)\s*/) {$_ = $heading = <AWRDATA>; }
	&process_awr_snap ($heading);
#--- Getting the Cache details.
	$_ = $heading = <AWRDATA>;
	until (/^\s*(Cache)/) {$_ = $heading = <AWRDATA>; }
	$_ = $heading = <AWRDATA>;
	&process_awr_cache ($heading);
#--- Getting the Profle details.
        $_ = $heading = <AWRDATA>;
        until (/^\s*(Load Profile)/) {$_ = $heading = <AWRDATA>; }
        $_ = $heading = <AWRDATA>;
	&process_awr_profile ($heading);
#--- Getting the Instance Effeciency details.
        $_ = $heading = <AWRDATA>;
	until (/^\s*(Instance Efficiency)/) {$_ = $heading = <AWRDATA>; }
        &process_awr_eff;
#--- Getting the Shared Pool Statistics.
        $_ = $heading = <AWRDATA>;
        until (/^\s*(Shared Pool Statistics)/) {$_ = $heading = <AWRDATA>; }
        &process_awr_sharedpool ($heading);
#--- Getting the Top 5 Timed Events.
        $_ = $heading = <AWRDATA>;
        until (/^Top 5 Timed/) {$_ = $heading = <AWRDATA>; }
        &process_awr_top ($heading);

#--- Getting the rest of the data.
        $_ = $heading = <AWRDATA>;
	until (/^\s*-+$/) {$_ = $heading = <AWRDATA>; }
	$_ = $heading = <AWRDATA>;	
	&process_section ();

#--- Getting the rest of the data.
	until (/^End of Report/) {
		$_ = $heading = <AWRDATA>;
		while (/^\n$/) {$_ = $heading = <AWRDATA>; }
	        unless (/^End of Report/) { &process_section ($heading); }
	}

	&close_awr_file;

}

# Main processing starts here.
if (@ARGV != 2) { die "Usage: awrstat.pl <input file> <output dir>"; }
($data_file, $out_dir) = @ARGV;
&process_report;
